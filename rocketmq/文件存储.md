# RocketMQ 文件存储

## 存储架构

RocketMQ的文件存储主要分为三部分，分别是CommitLog、IndexFile、以及ConsumeQueue 三部分，其中每一个broker都会对应一个commit log 文件用于存储当前broker的数据，然后针对于当前broker 在做数据查询时，我们可能会直接通过某一个messageId 来进行查找，那这个时候就需要index file 文件来进行辅助查找

存储架构如下：

- RPC层（NettyRemoteingServer、NettyServerHandler）
- 请求处理层（SendMessageProcessor、PullMessageProcessor、EndTransactionalProcessor、QueryMessageProcessor）
- Broker 业务逻辑层（MessageStore、CommitLog、ConsumeQueue、IndexFile）
- 文件映射层 （MappedFileQueue、MappedFile）
- 文件存储层（DISK)



消息添加的流程如下：

```sequence
participant MessageStore as store
participant CommitLog as commit_log
participant ScheduleMessage as schedule_message
participant MappedFileQueue as mapped_queue
participant MappedFile as mapped_file

store->commit_log: putMessage
commit_log-->schedule_message: 针对非事务消息以及事务提交类型的延迟消息\n 延迟消息topic：SCHEDULE_TOPIC_XXXX \n queueId: message.delayTimeLevel

schedule_message->schedule_message: 启动定时任务扫描
commit_log->mapped_queue: 获取最后一个MappedFile文件
commit_log->commit_log: 如果mappedFile不存在或者是剩余存储空间不够\n则创建一个新的MappedFile
commit_log->mapped_file: 添加信息 appendMessage

commit_log->commit_log: Statistics 统计
commit_log->commit_log: 处理数据刷盘
commit_log->commit_log: 处理主从复制
```



### MappedFile

MappedFile就表示实际在磁盘上存储的物理文件，MappedFile 中有几个比较重要的参数如下：

```java
    //commitLog内存（ByteBuffer）写入位点，标记消息写到哪了，下次从该位置开始写。
     //在消息写完后递增，递增大小为消息的长度

    // 1 mappedbytebuffer 文件系统缓存    2 专用写入缓存
    protected final AtomicInteger wrotePosition = new AtomicInteger(0);

    //提交位置
    protected final AtomicInteger committedPosition = new AtomicInteger(0);

    //文件系统缓存里边的内容，刷入磁盘的位置
    private final AtomicInteger flushedPosition = new AtomicInteger(0);
    
    //文件大小
    protected int fileSize;
    protected FileChannel fileChannel;
    /**
     * Message will put to here first, and then reput to FileChannel if writeBuffer is not null.
     */
    protected ByteBuffer writeBuffer = null;
    
    //用于分配写入缓存的的内存池
    protected TransientStorePool transientStorePool = null;
    
    //文件名称
    private String fileName;
    
    //当前文件其实的offset位置
    private long fileFromOffset;
    private File file;
    
    //当前文件对应的MappedByteBuffer
    private MappedByteBuffer mappedByteBuffer;
    private volatile long storeTimestamp = 0;
    
    //当前文件是否对应于MappedFileQueue中的第一个文件
    private boolean firstCreateInQueue = false;
```







MappedFile 添加消息的流程如下：

```sequence
participant MappedFile as mapped_file
participant AppendMessageCallback as callback

mapped_file->mapped_file: 获取当前writePosition的位置
mapped_file->mapped_file: 是否开启写入缓存，如果开启写入缓存则使用writeBuffer\n否则使用mappedByteBuffer

mapped_file->callback: doAppend 添加信息


```



