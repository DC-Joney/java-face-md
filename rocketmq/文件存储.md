# RocketMQ 文件存储

## 存储架构

RocketMQ的文件存储主要分为三部分，分别是CommitLog、IndexFile、以及ConsumeQueue 三部分，其中每一个broker都会对应一个commit log 文件用于存储当前broker的数据，然后针对于当前broker 在做数据查询时，我们可能会直接通过某一个messageId 来进行查找，那这个时候就需要index file 文件来进行辅助查找

存储架构如下：

- RPC层（NettyRemoteingServer、NettyServerHandler）
- 请求处理层（SendMessageProcessor、PullMessageProcessor、EndTransactionalProcessor、QueryMessageProcessor）
- Broker 业务逻辑层（MessageStore、CommitLog、ConsumeQueue、IndexFile）
- 文件映射层 （MappedFileQueue、MappedFile）
- 文件存储层（DISK)

![image-20221222173549643](assets/image-20221222173549643.png)





### 概览

在RocketMQ中所有涉及到文件存储的地方底层都是通过MappedFile实现的，以CommitLog为例，我们知道对于RocketMQ来说一个Broker对应了一个CommitLog文件，但是由于系统mmap的限制，一般在做mmap操作时都会将内存大小设置为1G，所以RocketMQ沿用了这样的方式，将CommitLog切分成了很多文件，每一个文件大小为 1G

RocketMQ的存储层核心点主要包括以下：

- DefaultMessageStore ：针对于broker存储层来说，其中包括 CommitLog、IndexFile、ConsumeQueue、Cleanup Thread等等
- CommitLog：用于存储当前broker的消息数据
- MappedFileQueue ：用于保存当前类型的所有MappedFile文件，比如基于ConsumeQueue 会有自己的MappedFileQueue对象，而基于CommitLog也会有自  己的MappedFileQueue对象
- AllocateMappedFileService ：用于创建MappedFile文件，并且如果开启文件预热功能则通过wramUp方法来进行文件预热
- MappedFile：每一个MappedFile 就对应于一个文件，内部通过mmap 做内存映射来提高性能
- ScheduleMessageService：用于处理定时任务信息，扫描各个delayLevel的 延时消息，如果到期则将消息添加到conmitlog中

![image-20221222203216263](assets/image-20221222203216263.png)



消息添加的流程如下：

```sequence
participant MessageStore as store
participant CommitLog as commit_log
participant ScheduleMessage as schedule_message
participant MappedFileQueue as mapped_queue
participant MappedFile as mapped_file

store->commit_log: putMessage
commit_log-->schedule_message: 针对非事务消息以及事务提交类型的延迟消息\n 延迟消息topic：SCHEDULE_TOPIC_XXXX \n queueId: message.delayTimeLevel

schedule_message->schedule_message: 启动定时任务扫描
commit_log->mapped_queue: 获取最后一个MappedFile文件
commit_log->commit_log: 如果mappedFile不存在或者是剩余存储空间不够\n则创建一个新的MappedFile
commit_log->mapped_file: 添加信息 appendMessage

commit_log->commit_log: Statistics 统计
commit_log->commit_log: 处理数据刷盘
commit_log->commit_log: 处理主从复制
```



### MappedFile

MappedFile就表示实际在磁盘上存储的物理文件，MappedFile 中有几个比较重要的参数如下：

```java
    //commitLog内存（ByteBuffer）写入位点，标记消息写到哪了，下次从该位置开始写。
     //在消息写完后递增，递增大小为消息的长度

    // 1 mappedbytebuffer 文件系统缓存    2 专用写入缓存
    protected final AtomicInteger wrotePosition = new AtomicInteger(0);

    //提交位置
    protected final AtomicInteger committedPosition = new AtomicInteger(0);

    //文件系统缓存里边的内容，刷入磁盘的位置
    private final AtomicInteger flushedPosition = new AtomicInteger(0);
    
    //文件大小
    protected int fileSize;
    protected FileChannel fileChannel;
    /**
     * Message will put to here first, and then reput to FileChannel if writeBuffer is not null.
     */
    protected ByteBuffer writeBuffer = null;
    
    //用于分配写入缓存的的内存池
    protected TransientStorePool transientStorePool = null;
    
    //文件名称
    private String fileName;
    
    //当前文件其实的offset位置
    private long fileFromOffset;
    private File file;
    
    //当前文件对应的MappedByteBuffer
    private MappedByteBuffer mappedByteBuffer;
    private volatile long storeTimestamp = 0;
    
    //当前文件是否对应于MappedFileQueue中的第一个文件
    private boolean firstCreateInQueue = false;
```



![image-20221226202755143](assets/image-20221226202755143.png)







MappedFile 添加消息的流程如下：

```sequence
participant MappedFile as mapped_file
participant AppendMessageCallback as callback

mapped_file->mapped_file: 获取当前writePosition的位置
mapped_file->mapped_file: 是否开启写入缓存，如果开启写入缓存则使用writeBuffer\n否则使用mappedByteBuffer

mapped_file->callback: doAppend 添加信息

callback->callback: 计算全局的物理其实偏移量：\nfileFromOffset+内存相对位置byteBuffer.position(wrotePosition)
callback->callback: 写入totalSize
callback->callback: 写入magic code
callback->callback: 写入topic
callback->callback: 写入queueId
callback->callback: 写入....
callback->callback: 写入当前消息对于topic+queue的相对offset\n既1,2,3,4 顺序增长
callback->callback: 返回写入结果:\n1、写入之前的全局物理其实位置\n2、消息的总长度

```







### MappedFileQueue

MappedFileQueue 主要用来保存创建完成的MappedFile文件，当MappedFile文件不存在或者是需要被创建时，会通过内部的AllocateMappedFileService来进行创建 核心属性如下：

```java
//MappedFileQueue对应的存储目录，既要对哪个目录下的文件做mmap内存映射
    private final String storePath;

    // CommitLog file size,default is 1G
    private final int mappedFileSize;
    
    //用于存储当前目录对应的所有MappedFile文件
    private final CopyOnWriteArrayList<MappedFile> mappedFiles = new CopyOnWriteArrayList<MappedFile>();

    //用于创建MappedFile文件
    private final AllocateMappedFileService allocateMappedFileService;

    //当前刷盘指针，表示该指针之前的所有数据全部持久化到硬盘
    private long flushedWhere = 0;

    //当前数据提交指针，内存中byteBuffer当前的写指针，该值大于等于 flushedWhere
    private long committedWhere = 0;
```



#### getLastMappedFile

getLastMappedFile 是从MappedFileQueue中获取最后一个MappedFile文件，如果获取不到或者是最后一个MappedFile文件已经满了，则会创建一个新的MappedFile文件放入到MappedFileQueue中



```sequence
participant CommitLog as commit_log
participant MappedFileQueue as mapped_queue
participant AllocateMappedFileService as allocate_service


commit_log->mapped_queue: 从MappedFileQueue中获取最新的MappedFile文件

mapped_queue->mapped_queue: "从mappedFiles集合中\n获取最后一个MappedFile文件"

mapped_queue->mapped_queue: 如果mappedFileLast 为空\n则通过startOffset计算出新文件的起始偏移量
mapped_queue->mapped_queue: 如果mappedFileLast已经满了，则通过最后一个\nmappedFile文件的fileFromOffset + mappedFileSize\n来计算新文件的其实偏移量

mapped_queue->mapped_queue: =====

mapped_queue-->allocate_service: 如果需要创建新的文件则通过\nallocateMappedFileService进行创建
mapped_queue->mapped_queue: 将新创建的MappedFile文件添加到mappedFiles集合中
mapped_queue->mapped_queue: 如果mappedFiles集合为空，则设置\n mappedFile.setFirstCreateInQueue(true);

```

```java

    public MappedFile getLastMappedFile(final long startOffset, boolean needCreate) {
        long createOffset = -1;

        // 获取要写入的CommitLog文件对应的 MappedFile
        MappedFile mappedFileLast = getLastMappedFile();

        //mappedFileLast 为空或者最后一个对象对应的文件已经写满，
        // 则创建一个新的文件（即新的 MapedFile 对象） ；
        // 计算出新文件的起始偏移量（起始偏移量就是文件名称）
        if (mappedFileLast == null) {
            createOffset = startOffset - (startOffset % this.mappedFileSize);
        }

        //如果可以获取到最后一个mappedfile 并且最后一个mappedfile也满了
        // createOffset = lastFileFromOffset + mappedFileSize
        if (mappedFileLast != null && mappedFileLast.isFull()) {
            createOffset = mappedFileLast.getFileFromOffset() + this.mappedFileSize;
        }

        if (createOffset != -1 && needCreate) {
            //下一个文件
            String nextFilePath = this.storePath + File.separator + UtilAll.offset2FileName(createOffset);

            //下下一个文件
            String nextNextFilePath = this.storePath + File.separator
                    + UtilAll.offset2FileName(createOffset + this.mappedFileSize);

            MappedFile mappedFile = null;

            // 判断 allocateMappedFileService 服务是否初始化，
            // 并创建下一个文件和下下一个文件
            if (this.allocateMappedFileService != null) {
				
                mappedFile = this.allocateMappedFileService.putRequestAndReturnMappedFile(nextFilePath,
                        nextNextFilePath, this.mappedFileSize);
            } else {
                try {

                    // 如果allocateMappedFileService 没有创建，则直接创建文件
                    mappedFile = new MappedFile(nextFilePath, this.mappedFileSize);
                } catch (IOException e) {
                    log.error("create mappedFile exception", e);
                }
            }

            //最后将创建或返回的 MapedFile 对象存入 MapedFileQueue 的 MapedFile 列表中，
            //并且将MappedFile的firstCreateInQUeue设置为true，表示当前MappedFile是在MappedFileQueue的第一个位置
            // 并返回该 MapedFile 对象给调用者
            if (mappedFile != null) {
                //如果mappedFiles集合为空，则将mappedFile的firstCreateInQueue属性设置为true，
                //表示当前MappedFile是MappedFileQueue中的第一个MappedFile文件
                if (this.mappedFiles.isEmpty()) {
                    mappedFile.setFirstCreateInQueue(true);
                }
                this.mappedFiles.add(mappedFile);
            }

            return mappedFile;
        }

        return mappedFileLast;
    }
```



#### flush

![image-20221226202742317](assets/image-20221226202742317.png)









刷盘线程主要分为一下三种：





### ConsumeQueue 存放数据

DefaultMessageStore#ReputMessageService





